#!/usr/bin/env bash
# codex-container-sandbox: run Codex CLI inside a Podman container with yolo.

set -euo pipefail

# ----------------------------
# Defaults (override via env or config)
# ----------------------------
: "${CODEX_CONTAINER_SANDBOX_IMAGE:=localhost/codex-container-sandbox:latest}"
: "${CODEX_CONTAINER_SANDBOX_CONTAINER_HOME:=/home/codex}"
: "${CODEX_CONTAINER_SANDBOX_STATE_DIR:=${XDG_STATE_HOME:-$HOME/.local/state}/codex-container-sandbox}"
: "${CODEX_CONTAINER_SANDBOX_CONFIG_FILE:=${XDG_CONFIG_HOME:-$HOME/.config}/codex-container-sandbox/config.sh}"
: "${CODEX_CONTAINER_SANDBOX_PODMAN:=podman}"
: "${CODEX_CONTAINER_SANDBOX_PODMAN_RUNTIME:=}"
: "${CODEX_CONTAINER_SANDBOX_AUTH_FILE:=}"
: "${CODEX_CONTAINER_SANDBOX_AUTH_MOUNT_MODE:=ro}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_AUTH_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_PROMPTS_DIR:=}"
: "${CODEX_CONTAINER_SANDBOX_SKILLS_DIR:=}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_PROMPTS_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_SKILLS_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_LOCAL_BIN_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_UV_TOOLS_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_UV_PYTHON_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_HOMEBREW_MOUNT:=0}"
: "${CODEX_CONTAINER_SANDBOX_HOMEBREW_PREFIX:=/home/linuxbrew/.linuxbrew}"
: "${CODEX_CONTAINER_SANDBOX_DISABLE_GIT_IDENTITY_SYNC:=0}"
: "${CODEX_CONTAINER_SANDBOX_GIT_NAME:=}"
: "${CODEX_CONTAINER_SANDBOX_GIT_EMAIL:=}"

# If set to 1, prints the computed podman command.
: "${CODEX_CONTAINER_SANDBOX_DEBUG:=0}"

# If set to 1, prints the `codex ...` command invoked inside the container.
# Default: on (so it's obvious what is being executed in-container).
: "${CODEX_CONTAINER_SANDBOX_PRINT_CODEX_CMD:=1}"

# If set to 1, keeps the container after exit (useful for debugging).
: "${CODEX_CONTAINER_SANDBOX_PERSIST:=0}"

# Extra mounts (arrays).
SANDBOX_RO_MOUNTS=()
SANDBOX_RW_MOUNTS=()

# Pass-through env vars into container (only if present in host env).
SANDBOX_ENV_PASSTHROUGH=()

# ----------------------------
# Load config (bash, optional)
# ----------------------------
if [[ -f "$CODEX_CONTAINER_SANDBOX_CONFIG_FILE" ]]; then
  # shellcheck disable=SC1090
  source "$CODEX_CONTAINER_SANDBOX_CONFIG_FILE"
fi

# Allow config to set these arrays using either bash arrays or whitespace-separated strings.
if declare -p CODEX_CONTAINER_SANDBOX_RO_MOUNTS >/dev/null 2>&1; then
  # shellcheck disable=SC2154
  SANDBOX_RO_MOUNTS+=("${CODEX_CONTAINER_SANDBOX_RO_MOUNTS[@]}")
elif [[ -n "${CODEX_CONTAINER_SANDBOX_RO_MOUNTS-}" ]]; then
  # shellcheck disable=SC2206
  SANDBOX_RO_MOUNTS+=(${CODEX_CONTAINER_SANDBOX_RO_MOUNTS})
fi

if declare -p CODEX_CONTAINER_SANDBOX_RW_MOUNTS >/dev/null 2>&1; then
  # shellcheck disable=SC2154
  SANDBOX_RW_MOUNTS+=("${CODEX_CONTAINER_SANDBOX_RW_MOUNTS[@]}")
elif [[ -n "${CODEX_CONTAINER_SANDBOX_RW_MOUNTS-}" ]]; then
  # shellcheck disable=SC2206
  SANDBOX_RW_MOUNTS+=(${CODEX_CONTAINER_SANDBOX_RW_MOUNTS})
fi

if declare -p CODEX_CONTAINER_SANDBOX_ENV_PASSTHROUGH >/dev/null 2>&1; then
  # shellcheck disable=SC2154
  SANDBOX_ENV_PASSTHROUGH+=("${CODEX_CONTAINER_SANDBOX_ENV_PASSTHROUGH[@]}")
elif [[ -n "${CODEX_CONTAINER_SANDBOX_ENV_PASSTHROUGH-}" ]]; then
  # shellcheck disable=SC2206
  SANDBOX_ENV_PASSTHROUGH+=(${CODEX_CONTAINER_SANDBOX_ENV_PASSTHROUGH})
fi

# ----------------------------
# Helper: usage
# ----------------------------
usage() {
  cat <<'EOF'
codex-container-sandbox - run Codex CLI in a Podman container with yolo

USAGE
  codex-container-sandbox [OPTIONS...] -- [CODEX_ARGS...]
  codex-container-sandbox [OPTIONS...] [CODEX_ARGS...]    # (also works; -- is optional)

OPTIONS
  --image IMAGE    Podman image to run (default: $CODEX_CONTAINER_SANDBOX_IMAGE)
  --ro PATH        Bind-mount PATH read-only (repeatable)
  --rw PATH        Bind-mount PATH read-write (repeatable)
  --state DIR      Host state dir for Codex HOME inside container
  --debug          Print the computed podman command
  --print-codex-cmd Print the computed `codex ...` command (default)
  --no-print-codex-cmd Disable printing the `codex ...` command
  --persist        Do not --rm the container (keeps it for inspection)
  --shell          Start an interactive shell in the container instead of running codex
  -h, --help       Show this help

NOTES
  - Always runs codex with --dangerously-bypass-approvals-and-sandbox and --sandbox danger-full-access.
  - Networking is enabled (no egress restrictions).
  - Web search tool is enabled (features.web_search_request=true).
EOF
}

# ----------------------------
# Parse args
# ----------------------------
RUN_SHELL=0
CODEX_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --image) CODEX_CONTAINER_SANDBOX_IMAGE="${2:?missing IMAGE}"; shift 2 ;;
    --ro) SANDBOX_RO_MOUNTS+=("${2:?missing PATH}"); shift 2 ;;
    --rw) SANDBOX_RW_MOUNTS+=("${2:?missing PATH}"); shift 2 ;;
    --state) CODEX_CONTAINER_SANDBOX_STATE_DIR="${2:?missing DIR}"; shift 2 ;;
    --debug) CODEX_CONTAINER_SANDBOX_DEBUG=1; shift ;;
    --print-codex-cmd) CODEX_CONTAINER_SANDBOX_PRINT_CODEX_CMD=1; shift ;;
    --no-print-codex-cmd) CODEX_CONTAINER_SANDBOX_PRINT_CODEX_CMD=0; shift ;;
    --persist) CODEX_CONTAINER_SANDBOX_PERSIST=1; shift ;;
    --shell) RUN_SHELL=1; shift ;;
    -h|--help) usage; exit 0 ;;
    --) shift; CODEX_ARGS+=("$@"); break ;;
    *) CODEX_ARGS+=("$1"); shift ;;
  esac
done

# ----------------------------
# Compute workspace mount
# ----------------------------
WORKSPACE_HOST="$(pwd -P)"
WORKSPACE_ROOT_HOST="$WORKSPACE_HOST"
if git -C "$WORKSPACE_HOST" rev-parse --show-toplevel >/dev/null 2>&1; then
  WORKSPACE_ROOT_HOST="$(git -C "$WORKSPACE_HOST" rev-parse --show-toplevel)"
fi
WORKSPACE_HOST="$(readlink -f "$WORKSPACE_HOST")"
WORKSPACE_ROOT_HOST="$(readlink -f "$WORKSPACE_ROOT_HOST")"
WORKSPACE_BASE="$(basename "$WORKSPACE_ROOT_HOST")"
CONTAINER_HOME="$CODEX_CONTAINER_SANDBOX_CONTAINER_HOME"
WORKSPACE_ROOT_CONT="$CONTAINER_HOME/$WORKSPACE_BASE"

if [[ "$WORKSPACE_HOST" == "$WORKSPACE_ROOT_HOST" ]]; then
  WORKSPACE_CONT="$WORKSPACE_ROOT_CONT"
elif [[ "$WORKSPACE_HOST" == "$WORKSPACE_ROOT_HOST/"* ]]; then
  rel="${WORKSPACE_HOST#$WORKSPACE_ROOT_HOST/}"
  WORKSPACE_CONT="$WORKSPACE_ROOT_CONT/$rel"
else
  WORKSPACE_CONT="$WORKSPACE_ROOT_CONT"
fi

# ----------------------------
# Prepare host state dir (0700)
# ----------------------------
install -d -m 0700 "$CODEX_CONTAINER_SANDBOX_STATE_DIR"
STATE_CONT="$CONTAINER_HOME/.codex"

# ----------------------------
# Optional: sync git identity into container global gitconfig
#
# This avoids "Author identity unknown" when making commits inside the container.
# We write the config into the host state dir so it persists across runs, then
# point GIT_CONFIG_GLOBAL at it in-container.
# ----------------------------
GIT_CONFIG_GLOBAL_HOST="$CODEX_CONTAINER_SANDBOX_STATE_DIR/gitconfig"
GIT_NAME=""
GIT_EMAIL=""

if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_GIT_IDENTITY_SYNC:-0}" -ne 1 ]]; then
  if [[ -n "${CODEX_CONTAINER_SANDBOX_GIT_NAME:-}" ]]; then
    GIT_NAME="$CODEX_CONTAINER_SANDBOX_GIT_NAME"
  else
    GIT_NAME="$(git config --get user.name 2>/dev/null || true)"
  fi

  if [[ -n "${CODEX_CONTAINER_SANDBOX_GIT_EMAIL:-}" ]]; then
    GIT_EMAIL="$CODEX_CONTAINER_SANDBOX_GIT_EMAIL"
  else
    GIT_EMAIL="$(git config --get user.email 2>/dev/null || true)"
  fi

  if command -v git >/dev/null 2>&1; then
    if [[ -n "${GIT_NAME:-}" ]]; then
      git config --file "$GIT_CONFIG_GLOBAL_HOST" user.name "$GIT_NAME" >/dev/null 2>&1 || true
    fi
    if [[ -n "${GIT_EMAIL:-}" ]]; then
      git config --file "$GIT_CONFIG_GLOBAL_HOST" user.email "$GIT_EMAIL" >/dev/null 2>&1 || true
    fi
  fi

  if [[ -z "${GIT_NAME:-}" || -z "${GIT_EMAIL:-}" ]]; then
    echo "[codex-container-sandbox] WARN: git identity not fully set (user.name/user.email); commits may fail." >&2
    echo "[codex-container-sandbox]       Fix on host: git config --global user.name \"...\"; git config --global user.email \"...\"" >&2
    echo "[codex-container-sandbox]       Or override: CODEX_CONTAINER_SANDBOX_GIT_NAME / CODEX_CONTAINER_SANDBOX_GIT_EMAIL" >&2
  fi
fi

# ----------------------------
# Optional: reuse host Codex auth.json
# ----------------------------
AUTH_HOST=""
if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_AUTH_MOUNT:-0}" -ne 1 ]]; then
  if [[ -n "${CODEX_CONTAINER_SANDBOX_AUTH_FILE:-}" ]]; then
    AUTH_HOST="$CODEX_CONTAINER_SANDBOX_AUTH_FILE"
  elif [[ -r "$HOME/.codex/auth.json" ]]; then
    AUTH_HOST="$HOME/.codex/auth.json"
  fi
fi

if [[ -n "${AUTH_HOST:-}" ]]; then
  AUTH_HOST="$(readlink -f "$AUTH_HOST" 2>/dev/null || echo "$AUTH_HOST")"
  if [[ ! -r "$AUTH_HOST" ]]; then
    echo "[codex-container-sandbox] auth file not readable; skipping mount: $AUTH_HOST" >&2
    AUTH_HOST=""
  fi
fi

PROMPTS_HOST=""
if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_PROMPTS_MOUNT:-0}" -ne 1 ]]; then
  if [[ -n "${CODEX_CONTAINER_SANDBOX_PROMPTS_DIR:-}" ]]; then
    PROMPTS_HOST="$CODEX_CONTAINER_SANDBOX_PROMPTS_DIR"
  elif [[ -d "$HOME/.codex/prompts" ]]; then
    PROMPTS_HOST="$HOME/.codex/prompts"
  fi
fi
if [[ -n "${PROMPTS_HOST:-}" ]]; then
  PROMPTS_HOST="$(readlink -f "$PROMPTS_HOST" 2>/dev/null || echo "$PROMPTS_HOST")"
  if [[ ! -d "$PROMPTS_HOST" ]] || [[ ! -r "$PROMPTS_HOST" ]]; then
    echo "[codex-container-sandbox] prompts dir not readable; skipping mount: $PROMPTS_HOST" >&2
    PROMPTS_HOST=""
  fi
fi

SKILLS_HOST=""
if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_SKILLS_MOUNT:-0}" -ne 1 ]]; then
  if [[ -n "${CODEX_CONTAINER_SANDBOX_SKILLS_DIR:-}" ]]; then
    SKILLS_HOST="$CODEX_CONTAINER_SANDBOX_SKILLS_DIR"
  elif [[ -d "$HOME/.codex/skills" ]]; then
    SKILLS_HOST="$HOME/.codex/skills"
  fi
fi
if [[ -n "${SKILLS_HOST:-}" ]]; then
  SKILLS_HOST="$(readlink -f "$SKILLS_HOST" 2>/dev/null || echo "$SKILLS_HOST")"
  if [[ ! -d "$SKILLS_HOST" ]] || [[ ! -r "$SKILLS_HOST" ]]; then
    echo "[codex-container-sandbox] skills dir not readable; skipping mount: $SKILLS_HOST" >&2
    SKILLS_HOST=""
  fi
fi

# ----------------------------
# Helper: add a mount only once (avoids duplicate -v flags)
# ----------------------------
add_ro_mount_unique() {
  local p="${1:?missing path}"
  local resolved_p
  resolved_p="$(readlink -f "$p" 2>/dev/null || echo "$p")"
  local existing resolved_existing
  for existing in "${SANDBOX_RO_MOUNTS[@]}"; do
    resolved_existing="$(readlink -f "$existing" 2>/dev/null || echo "$existing")"
    if [[ "$resolved_existing" == "$resolved_p" ]]; then
      return 0
    fi
  done
  SANDBOX_RO_MOUNTS+=("$p")
}

# Host ~/.local/bin (optional). Useful for host-installed helper CLIs like read-pdf.
if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_LOCAL_BIN_MOUNT:-0}" -ne 1 ]]; then
  if [[ -d "$HOME/.local/bin" ]]; then
    for tool in read-pdf ttok; do
      if command -v "$tool" >/dev/null 2>&1; then
        tool_path="$(command -v "$tool" 2>/dev/null || true)"
        if [[ "$tool_path" == "$HOME/.local/bin/$tool" ]]; then
          add_ro_mount_unique "$HOME/.local/bin"
          break
        fi
      fi
    done
  fi
fi

# Host uv tools (optional). Needed when host CLIs in ~/.local/bin are symlinks to
# ~/.local/share/uv/tools/... (common for uv tool installs like ttok/markitdown).
UV_TOOLS_HOST=""
UV_PYTHON_HOST=""
if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_UV_TOOLS_MOUNT:-0}" -ne 1 ]]; then
  uv_tools_default="$HOME/.local/share/uv/tools"
  if [[ -d "$uv_tools_default" ]]; then
    # The image ships with markitdown; only auto-mount uv tools when we need a
    # host-installed uv tool (e.g., ttok).
    for tool in ttok; do
      if command -v "$tool" >/dev/null 2>&1; then
        tool_path="$(command -v "$tool" 2>/dev/null || true)"
        tool_target="$(readlink -f "$tool_path" 2>/dev/null || echo "$tool_path")"
        if [[ "$tool_target" == "$uv_tools_default/"* ]]; then
          UV_TOOLS_HOST="$uv_tools_default"
          if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_UV_PYTHON_MOUNT:-0}" -ne 1 ]] && [[ -d "$HOME/.local/share/uv/python" ]]; then
            UV_PYTHON_HOST="$HOME/.local/share/uv/python"
          fi
          break
        fi
      fi
    done
  fi
fi

HOMEBREW_HOST=""
if [[ "${CODEX_CONTAINER_SANDBOX_DISABLE_HOMEBREW_MOUNT:-0}" -ne 1 ]]; then
  brew_prefix="${CODEX_CONTAINER_SANDBOX_HOMEBREW_PREFIX:-/home/linuxbrew/.linuxbrew}"
  if [[ -d "$brew_prefix" ]]; then
    # The image ships with pandoc + mq. Only auto-mount Homebrew for tools we
    # intentionally don't vendor into the image.
    for tool in yq jq; do
      if command -v "$tool" >/dev/null 2>&1; then
        tool_path="$(command -v "$tool" 2>/dev/null || true)"
        tool_target="$(readlink -f "$tool_path" 2>/dev/null || echo "$tool_path")"
        if [[ "$tool_target" == "$brew_prefix/"* ]]; then
          HOMEBREW_HOST="$brew_prefix"
          break
        fi
      fi
    done
  fi
fi

# ----------------------------
# Helper: map a host path -> container path
#  - if under $HOME, preserve relative path under container home
#  - else, mount to the same absolute path
# ----------------------------
map_path() {
  local host_path="$1"
  host_path="$(readlink -f "$host_path")"
  if [[ "$host_path" == "$HOME/"* ]]; then
    local rel="${host_path#$HOME/}"
    echo "$CONTAINER_HOME/$rel"
  else
    echo "$host_path"
  fi
}

# ----------------------------
# Build podman args
# ----------------------------
PODMAN_ARGS=()

# OCI runtime.
# On some WSL environments, `crun` may fail with "unknown version specified";
# default to `runc` there unless the user explicitly overrides.
if [[ -z "${CODEX_CONTAINER_SANDBOX_PODMAN_RUNTIME:-}" ]]; then
  if uname -r 2>/dev/null | grep -qiE 'microsoft|wsl'; then
    CODEX_CONTAINER_SANDBOX_PODMAN_RUNTIME="runc"
  fi
fi
if [[ -n "${CODEX_CONTAINER_SANDBOX_PODMAN_RUNTIME:-}" ]]; then
  PODMAN_ARGS+=( --runtime "$CODEX_CONTAINER_SANDBOX_PODMAN_RUNTIME" )
fi

# tty / interactive only if stdout is a tty
if [[ -t 0 && -t 1 ]]; then
  PODMAN_ARGS+=( -it )
else
  PODMAN_ARGS+=( -i )
fi

if [[ "$CODEX_CONTAINER_SANDBOX_PERSIST" -eq 0 ]]; then
  PODMAN_ARGS+=( --rm )
fi

# Rootless Podman default user mapping makes host-owned bind mounts appear as
# owned by container uid 0. Use keep-id so the invoking host UID/GID map to the
# same IDs in-container, then run as that user so the mounted workspace remains
# writable without creating root-owned files on the host.
PODMAN_ARGS+=( --userns=keep-id )
PODMAN_ARGS+=( --user "$(id -u):$(id -g)" )

# Keep it predictable
PODMAN_ARGS+=( --env "HOME=$CONTAINER_HOME" --env "USER=${USER:-codex}" )
PODMAN_ARGS+=( --env "CODEX_HOME=$STATE_CONT" )
PODMAN_ARGS+=( --workdir "$WORKSPACE_CONT" )

# Use a persistent git global config under CODEX_HOME.
# (git reads this env var as the preferred global config path)
PODMAN_ARGS+=( --env "GIT_CONFIG_GLOBAL=$STATE_CONT/gitconfig" )

# Also pass explicit author/committer identity if we have it.
if [[ -n "${GIT_NAME:-}" ]]; then
  PODMAN_ARGS+=( --env "GIT_AUTHOR_NAME=$GIT_NAME" --env "GIT_COMMITTER_NAME=$GIT_NAME" )
fi
if [[ -n "${GIT_EMAIL:-}" ]]; then
  PODMAN_ARGS+=( --env "GIT_AUTHOR_EMAIL=$GIT_EMAIL" --env "GIT_COMMITTER_EMAIL=$GIT_EMAIL" )
fi

# Minimal PATH with typical user bins first (+ optional Homebrew)
container_path="$CONTAINER_HOME/.local/bin:$CONTAINER_HOME/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
if [[ -n "${HOMEBREW_HOST:-}" ]]; then
  container_path="$container_path:$HOMEBREW_HOST/bin"
fi
PODMAN_ARGS+=( --env "PATH=$container_path" )

# Put common tool caches inside the mounted state dir by default.
PODMAN_ARGS+=( --env "XDG_CACHE_HOME=$STATE_CONT/cache" )

# Workspace RW (root or current dir)
PODMAN_ARGS+=( -v "$WORKSPACE_ROOT_HOST:$WORKSPACE_ROOT_CONT:rw" )

# Codex state dir RW
PODMAN_ARGS+=( -v "$CODEX_CONTAINER_SANDBOX_STATE_DIR:$STATE_CONT:rw" )

# Host auth.json (optional). Mount after CODEX_HOME dir so the file overlays.
if [[ -n "${AUTH_HOST:-}" ]]; then
  case "${CODEX_CONTAINER_SANDBOX_AUTH_MOUNT_MODE:-ro}" in
    ro|rw) ;;
    *)
      echo "[codex-container-sandbox] invalid CODEX_CONTAINER_SANDBOX_AUTH_MOUNT_MODE=${CODEX_CONTAINER_SANDBOX_AUTH_MOUNT_MODE}; use ro or rw" >&2
      exit 2
      ;;
  esac
  PODMAN_ARGS+=( -v "$AUTH_HOST:$STATE_CONT/auth.json:${CODEX_CONTAINER_SANDBOX_AUTH_MOUNT_MODE}" )
fi

# Host prompts/skills (optional). Mount after CODEX_HOME dir so they overlay and remain RO.
if [[ -n "${PROMPTS_HOST:-}" ]]; then
  PODMAN_ARGS+=( -v "$PROMPTS_HOST:$STATE_CONT/prompts:ro" )
fi
if [[ -n "${SKILLS_HOST:-}" ]]; then
  PODMAN_ARGS+=( -v "$SKILLS_HOST:$STATE_CONT/skills:ro" )
fi

# Host uv tools and Homebrew prefix (optional). These are mounted to their
# original absolute paths to keep host-installed symlinks and ELF RPATHs working.
if [[ -n "${UV_TOOLS_HOST:-}" ]]; then
  PODMAN_ARGS+=( -v "$UV_TOOLS_HOST:$UV_TOOLS_HOST:ro" )
fi
if [[ -n "${UV_PYTHON_HOST:-}" ]]; then
  PODMAN_ARGS+=( -v "$UV_PYTHON_HOST:$UV_PYTHON_HOST:ro" )
fi
if [[ -n "${HOMEBREW_HOST:-}" ]]; then
  PODMAN_ARGS+=( -v "$HOMEBREW_HOST:$HOMEBREW_HOST:ro" )
fi

# Extra mounts from config/flags
for p in "${SANDBOX_RO_MOUNTS[@]}"; do
  [[ -e "$p" ]] || { echo "[codex-container-sandbox] RO mount missing: $p" >&2; exit 2; }
  PODMAN_ARGS+=( -v "$(readlink -f "$p"):$(map_path "$p"):ro" )
done

for p in "${SANDBOX_RW_MOUNTS[@]}"; do
  [[ -e "$p" ]] || { echo "[codex-container-sandbox] RW mount missing: $p" >&2; exit 2; }
  PODMAN_ARGS+=( -v "$(readlink -f "$p"):$(map_path "$p"):rw" )
done

# Env passthrough
for var in "${SANDBOX_ENV_PASSTHROUGH[@]}"; do
  if [[ -n "${!var-}" ]]; then
    PODMAN_ARGS+=( --env "$var" )
  fi
done

# ----------------------------
# Assemble codex command
# ----------------------------
if [[ "$RUN_SHELL" -eq 1 ]]; then
  CONTAINER_CMD=( bash -l )
else
  CONTAINER_CMD=( codex )
  # Always enable web search tool availability for the agent. We do this via
  # feature enabling instead of relying on `--search`, because `--search` is a
  # top-level flag (and does not exist on `codex exec` itself).
  CONTAINER_CMD+=( --enable web_search_request )
  exec_idx=-1
  for i in "${!CODEX_ARGS[@]}"; do
    if [[ "${CODEX_ARGS[$i]}" == "exec" || "${CODEX_ARGS[$i]}" == "e" ]]; then
      exec_idx="$i"
      break
    fi
  done

  if [[ "$exec_idx" -ge 0 ]]; then
    before_exec=( "${CODEX_ARGS[@]:0:$((exec_idx+1))}" )
    after_exec=( "${CODEX_ARGS[@]:$((exec_idx+1))}" )

    # Remove any global-yolo flags from before_exec, since `codex exec` has its
    # own copies of these options and the top-level ones don't affect exec.
    before_exec_clean=()
    i=0
    while [[ "$i" -lt "${#before_exec[@]}" ]]; do
      case "${before_exec[$i]}" in
        --sandbox|-s|--ask-for-approval|-a)
          i=$((i+2))
          ;;
        --yolo|--dangerously-bypass-approvals-and-sandbox|--full-auto)
          i=$((i+1))
          ;;
        *)
          before_exec_clean+=( "${before_exec[$i]}" )
          i=$((i+1))
          ;;
      esac
    done

    has_bypass=0
    has_sandbox=0
    for arg in "${after_exec[@]}"; do
      if [[ "$arg" == "--dangerously-bypass-approvals-and-sandbox" || "$arg" == "--yolo" ]]; then
        has_bypass=1
      elif [[ "$arg" == "--sandbox" || "$arg" == "-s" ]]; then
        has_sandbox=1
      fi
    done

    injected=()
    if [[ "$has_bypass" -eq 0 ]]; then
      injected+=( --dangerously-bypass-approvals-and-sandbox )
    fi
    if [[ "$has_sandbox" -eq 0 ]]; then
      injected+=( --sandbox danger-full-access )
    fi

    CONTAINER_CMD+=( "${before_exec_clean[@]}" "${injected[@]}" "${after_exec[@]}" )
  else
    # No exec subcommand found; inject at the top level.
    has_bypass=0
    has_sandbox=0
    for arg in "${CODEX_ARGS[@]}"; do
      if [[ "$arg" == "--dangerously-bypass-approvals-and-sandbox" || "$arg" == "--yolo" ]]; then
        has_bypass=1
      elif [[ "$arg" == "--sandbox" || "$arg" == "-s" ]]; then
        has_sandbox=1
      fi
    done

    if [[ "$has_bypass" -eq 0 ]]; then
      CONTAINER_CMD+=( --dangerously-bypass-approvals-and-sandbox )
    fi
    if [[ "$has_sandbox" -eq 0 ]]; then
      CONTAINER_CMD+=( --sandbox danger-full-access )
    fi
    CONTAINER_CMD+=( "${CODEX_ARGS[@]}" )
  fi
fi

# ----------------------------
# Run
# ----------------------------
FULL_CMD=( "$CODEX_CONTAINER_SANDBOX_PODMAN" run "${PODMAN_ARGS[@]}" "$CODEX_CONTAINER_SANDBOX_IMAGE" "${CONTAINER_CMD[@]}" )

if [[ "$CODEX_CONTAINER_SANDBOX_DEBUG" -eq 1 || "$CODEX_CONTAINER_SANDBOX_PRINT_CODEX_CMD" -eq 1 ]]; then
  echo "[codex-container-sandbox] container cmd:" >&2
  printf '  %q' "${CONTAINER_CMD[@]}" >&2
  echo >&2
fi

if [[ "$CODEX_CONTAINER_SANDBOX_DEBUG" -eq 1 ]]; then
  echo "[codex-container-sandbox] podman cmd:" >&2
  printf '  %q' "${FULL_CMD[@]}" >&2
  echo >&2
fi

exec "${FULL_CMD[@]}"
